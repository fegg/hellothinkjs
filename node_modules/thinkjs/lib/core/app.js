'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;

var _cluster = require('cluster');

var _cluster2 = _interopRequireDefault(_cluster);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _domain = require('domain');

var _domain2 = _interopRequireDefault(_domain);

var _os = require('os');

var _os2 = _interopRequireDefault(_os);

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _default = (function (_think$http$base) {
  _inherits(_default, _think$http$base);

  function _default() {
    _classCallCheck(this, _default);

    _think$http$base.apply(this, arguments);
  }

  /**
   * exec logic
   * @return {Promise} []
   */

  _default.prototype.execLogic = function execLogic() {
    var name = this.http.module + '/' + think.dirname.logic + '/' + this.http.controller;
    var cls = think.require(name, true);
    if (!cls) {
      return _Promise.resolve();
    }
    var instance = new cls(this.http);
    var action = think.camelCase(this.http.action);
    if (think.isFunction(instance[action + 'Action'])) {
      return this.action(instance, action);
    }
    //call action
    else if (think.isFunction(instance.__call)) {
        return this.action(instance, '__call');
      }
      //only has before method
      else if (think.isFunction(instance.__before)) {
          return think.co.wrap(instance.__before).bind(instance)(instance);
        }
    return _Promise.resolve();
  };

  /**
   * exec controller
   * @return {Promise} []
   */

  _default.prototype.execController = function execController() {
    var http = this.http;
    var name = http.module + '/' + think.dirname.controller + '/' + http.controller;
    var cls = think.require(name, true);
    if (cls) {
      return this.execAction(new cls(http));
    }
    http.error = new Error(think.locale('CONTROLLER_NOT_FOUND', http.controller, http.url));
    return think.statusAction(404, http);
  };

  /**
   * exec action
   * @param  {Object} controller [controller instance]
   * @param  {Boolean} call       [is call controller]
   * @return {Promise}            []
   */

  _default.prototype.execAction = function execAction(controller) {
    var http = this.http;
    //if is rest api, rewrite action
    if (controller._isRest) {
      var method = controller._method;
      //get method from GET params
      if (method) {
        method = controller.get(method).toLowerCase();
      }
      if (!method) {
        method = http.method.toLowerCase();
      }
      http.action = method;
    }
    var action = think.camelCase(http.action);
    var actionWithSuffix = action + 'Action';
    //action is exist
    if (think.isFunction(controller[actionWithSuffix])) {
      return this.action(controller, action);
    }
    //call action
    if (think.isFunction(controller.__call)) {
      return this.action(controller, '__call');
    }
    http.error = new Error(think.locale('ACTION_NOT_FOUND', actionWithSuffix, http.url));
    return think.statusAction(404, http);
  };

  /**
   * exec 
   * @return {Promise} []
   */

  _default.prototype.exec = function exec() {
    return _regeneratorRuntime.async(function exec$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(this.hook('resource'));

        case 2:
          context$2$0.next = 4;
          return _regeneratorRuntime.awrap(this.hook('route_parse'));

        case 4:

          //set module config, can not set config in request
          this.http._config = think.getModuleConfig(this.http.module);

          //babel compile error

          if (!think.compileError) {
            context$2$0.next = 8;
            break;
          }

          this.http.error = think.compileError;
          return context$2$0.abrupt('return', think.statusAction(500, this.http));

        case 8:
          context$2$0.next = 10;
          return _regeneratorRuntime.awrap(this.hook('logic_before'));

        case 10:
          context$2$0.next = 12;
          return _regeneratorRuntime.awrap(this.execLogic()['catch'](function (err) {
            //ignore prevent reject promise
            //make logic_after hook can be invoked
            if (!think.isPrevent(err)) {
              return _Promise.reject(err);
            }
          }));

        case 12:
          context$2$0.next = 14;
          return _regeneratorRuntime.awrap(this.hook('logic_after'));

        case 14:
          if (!this.http._isEnd) {
            context$2$0.next = 16;
            break;
          }

          return context$2$0.abrupt('return', think.prevent());

        case 16:
          context$2$0.next = 18;
          return _regeneratorRuntime.awrap(this.hook('controller_before'));

        case 18:
          context$2$0.next = 20;
          return _regeneratorRuntime.awrap(this.execController()['catch'](function (err) {
            //ignore prevent reject promise
            //make controller_after & response_end hook can be invoked
            if (!think.isPrevent(err)) {
              return _Promise.reject(err);
            }
          }));

        case 20:
          context$2$0.next = 22;
          return _regeneratorRuntime.awrap(this.hook('controller_after'));

        case 22:
          context$2$0.next = 24;
          return _regeneratorRuntime.awrap(this.hook('response_end'));

        case 24:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * run
   * @return {} []
   */

  _default.prototype.run = function run() {
    var _this = this;

    var http = this.http;
    http.header('X-Powered-By', 'thinkjs-' + think.version);
    //service off
    if (!think.config('service_on')) {
      http.error = new Error(think.locale('SERVICE_UNAVAILABLE'));
      return think.statusAction(503, http);
    }
    //deny access by ip + port
    if (think.config('proxy_on') && http.host !== http.hostname && !http.socket) {
      http.error = new Error(think.locale('DISALLOW_PORT'));
      return think.statusAction(403, http);
    }

    var instance = _domain2['default'].create();
    instance.on('error', function (err) {
      http.error = err;
      think.statusAction(500, http, true);
    });
    instance.run(function callee$2$0() {
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            context$3$0.prev = 0;
            context$3$0.next = 3;
            return _regeneratorRuntime.awrap(this.exec());

          case 3:
            context$3$0.next = 9;
            break;

          case 5:
            context$3$0.prev = 5;
            context$3$0.t0 = context$3$0['catch'](0);

            http.error = context$3$0.t0;
            think.statusAction(500, http, true);

          case 9:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this, [[0, 5]]);
    });
  };

  /**
   * create server
   * @return {} []
   */

  _default.createServer = function createServer() {
    var _this2 = this;

    var handle = think.config('create_server');
    var host = think.config('host');
    var port = think.port || think.config('port');
    //createServer callback
    var callback = function callback(req, res) {
      var http;
      return _regeneratorRuntime.async(function callback$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            context$3$0.next = 2;
            return _regeneratorRuntime.awrap(think.http(req, res));

          case 2:
            http = context$3$0.sent;
            return context$3$0.abrupt('return', new this(http).run());

          case 4:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this2);
    };
    var server = undefined;
    //define createServer in application
    if (handle) {
      server = handle(callback, port, host, this);
    } else {
      //create server
      server = _http2['default'].createServer(callback);
      server.listen(port, host);
    }
    this.logPid(port);

    //start websocket
    var websocket = think.parseConfig(think.config('websocket'));
    if (websocket.on) {
      var Cls = think.adapter('websocket', websocket.type);
      var instance = new Cls(server, websocket, this);
      instance.run();
    }
  };

  /**
   * log
   * @return {} []
   */

  _default.log = function log() {
    var host = think.config('host');
    var port = think.port || think.config('port');
    var websocketStatus = think.config('websocket.on') ? 'open' : 'closed';
    var clusterStatus = think.config('cluster_on') ? 'open' : 'closed';

    think.log('Server running at http://' + (host || '127.0.0.1') + ':' + port + '/', 'THINK');
    think.log(function () {
      return 'ThinkJS Version: ' + think.version;
    }, 'THINK');
    think.log(function (colors) {
      return 'Cluster Status: ' + colors.magenta(clusterStatus);
    }, 'THINK');
    think.log(function (colors) {
      return 'WebSocket Status: ' + colors.magenta(websocketStatus);
    }, 'THINK');
    think.log(function (colors) {
      return 'File Auto Compile: ' + colors.magenta(!!think.autoCompile);
    }, 'THINK');
    think.log(function (colors) {
      return 'File Auto Reload: ' + colors.magenta(think.config('auto_reload'));
    }, 'THINK');
    think.log(function (colors) {
      return 'App Enviroment: ' + colors.magenta(think.env) + '\n';
    }, 'THINK');
  };

  /**
   * cli mode
   * @return {} []
   */

  _default.cli = function cli() {
    var http;
    return _regeneratorRuntime.async(function cli$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(think.http(think.cli));

        case 2:
          http = context$2$0.sent;
          return context$2$0.abrupt('return', new this(http).run());

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  /**
   * load process id
   * @return {} []
   */

  _default.logPid = function logPid(port) {
    if (!_cluster2['default'].isMaster || !think.config('log_pid')) {
      return;
    }
    var dir = think.getPath(undefined, think.dirname.runtime) + '/pid';
    think.mkdir(dir);
    var pidFile = dir + '/' + port + '.pid';
    _fs2['default'].writeFileSync(pidFile, process.pid);
    //change pid file mode
    think.chmod(pidFile);
    //remove pid file when process exit
    process.on('SIGTERM', function () {
      if (_fs2['default'].existsSync(pidFile)) {
        _fs2['default'].unlinkSync(pidFile);
      }
      process.exit(0);
    });
  };

  /**
   * http mode
   * @return {} []
   */

  _default.http = function http() {
    var nums = think.config('cluster_on');
    if (!nums) {
      this.createServer();
      return this.log();
    }
    if (nums === true) {
      nums = _os2['default'].cpus().length;
    }
    if (_cluster2['default'].isMaster) {
      for (var i = 0; i < nums; i++) {
        _cluster2['default'].fork();
      }
      _cluster2['default'].on('exit', function (worker) {
        think.log(new Error(think.locale('WORKER_DIED', worker.process.pid)), 'THINK');
        process.nextTick(function () {
          return _cluster2['default'].fork();
        });
      });
      this.log();
    } else {
      this.createServer();
    }
  };

  /**
   * run
   * @return {} []
   */

  _default.run = function run() {
    if (think.cli) {
      return this.cli();
    }
    return this.http();
  };

  return _default;
})(think.http.base);

exports['default'] = _default;
module.exports = exports['default'];

//http is end