'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

exports.__esModule = true;

var _default = (function (_think$base) {
  _inherits(_default, _think$base);

  function _default() {
    _classCallCheck(this, _default);

    _think$base.apply(this, arguments);
  }

  /**
   * init
   * @return {} []
   */

  _default.prototype.init = function init() {
    this.comparison = {
      'EQ': '$eq',
      '=': '$eq',
      'NEQ': '$ne',
      '!=': '$ne',
      '<>': '$ne',
      'GT': '$gt',
      '>': '$gt',
      'EGT': '$gte',
      '>=': '$gte',
      'LT': '$lt',
      '<': '$lt',
      'ELT': '$lte',
      '<=': '$lte',
      'OR': '$or',
      'IN': '$in',
      'NOTIN': '$nin'
    };
  };

  /**
   * parse field
   * @param  {String} field   []
   * @param  {Boolean} reverse []
   * @return {Object}         []
   */

  _default.prototype.parseField = function parseField(field, reverse) {
    if (!field) {
      return {};
    }
    if (think.isString(field)) {
      field = field.split(/\s*,\s*/);
    }
    if (think.isArray(field)) {
      var _ret = (function () {
        var result = {};
        field.forEach(function (item) {
          result[item] = reverse ? 0 : 1;
        });
        return {
          v: result
        };
      })();

      if (typeof _ret === 'object') return _ret.v;
    }
    if (reverse) {
      for (var key in field) {
        field[key] = 0;
      }
    }
    return field;
  };

  /**
   * parse limit
   * @param  {Object} collection []
   * @param  {Array} limit      []
   * @return {Object}            []
   */

  _default.prototype.parseLimit = function parseLimit(limit) {
    if (!limit) {
      return [];
    }
    if (think.isNumber(limit)) {
      return [0, limit];
    }
    if (think.isString(limit)) {
      limit = limit.split(/\s*,\s*/);
    }
    var skip = limit[0] | 0;
    var limitNum = limit[1] | 0;
    if (limitNum) {
      return [skip, limitNum];
    }
    return [0, skip];
  };

  /**
   * parse order
   * @param  {String} order []
   * @return {Object}       []
   */

  _default.prototype.parseOrder = function parseOrder(order) {
    if (!order) {
      return {};
    }
    if (order === true || order === 'natural') {
      return {
        $natural: 1
      };
    }
    if (think.isString(order)) {
      var _ret2 = (function () {
        order = order.split(/\s*,\s*/);
        var result = {};
        order.forEach(function (item) {
          item = item.split(' ');
          var type = (item[1] || '').toLowerCase();
          result[item[0].trim()] = type === 'desc' ? -1 : 1;
        });
        return {
          v: result
        };
      })();

      if (typeof _ret2 === 'object') return _ret2.v;
    }
    for (var key in order) {
      if (order[key] === false || order[key] === 0) {
        order[key] = -1;
      } else if (order[key] !== -1) {
        order[key] = 1;
      }
    }
    return order;
  };

  /**
   * parse group
   * @param  {String} group []
   * @return {Object}       []
   */

  _default.prototype.parseGroup = function parseGroup(group) {
    if (think.isEmpty(group)) {
      return '';
    }
    if (think.isString(group)) {
      group = group.split(/\s*,\s*/);
    }
    return group;
  };

  /**
   * parse where
   * http://docs.mongodb.org/manual/reference/operator/query/
   * @param  {Object} where []
   * @return {Object}       []
   */

  _default.prototype.parseWhere = function parseWhere(where) {
    var _this = this;

    if (think.isArray(where)) {
      return where.map(function (item) {
        return _this.parseWhere(item);
      });
    }

    if (think.isObject(where)) {
      var result = {};
      for (var key in where) {
        var value = where[key];
        if (key === '_id') {
          var validator = think.require('validator');
          if (validator.mongoId(value)) {
            var _think$require = think.require('mongodb');

            var ObjectID = _think$require.ObjectID;

            result[key] = ObjectID(value);
            continue;
          }
        }
        key = this.comparison[key] || key;
        if (think.isObject(value) || think.isArray(value)) {
          value = this.parseWhere(value);
        }
        result[key] = value;
      }
      return result;
    }
    return where || {};
  };

  /**
   * parse distinct
   * @param  {String} distinct []
   * @return {String}          []
   */

  _default.prototype.parseDistinct = function parseDistinct(distinct) {
    return distinct;
  };

  return _default;
})(think.base);

exports['default'] = _default;
module.exports = exports['default'];